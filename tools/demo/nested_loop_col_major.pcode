sym N, M
var i, j
decl A, B
out A
(A[1*N+1 : M*N+N], B[1*N+1 : M*N+N] => A[1*N+1 : M*N+N]) L_outer | for i = 1 to N:
  (A[1*N+i : M*N+i], A[1*N+(i-1) : M*N+(i-1)], B[1*N+i : M*N+i] => A[1*N+i : M*N+i]) L_inner | for j = 1 to M:
    (A[j*N+(i-1)], A[j*N+i], B[j*N+i] => A[j*N+i]) T_comp | op(comp)

;
; This example demonstrates a nested loop with explicit column-major access patterns.
; The inner loop's access `A[j*N+(i-1)]` indicates a read from a previous
; iteration in the 'i' dimension.
;
; Expected SMT Result: SAT
; Reason: The access `A[j*N+(i-1)]` implies a read from data potentially written
; by an earlier computation involving `i-1`. This creates a true data dependency
; across iterations in the `i` dimension within the inner loop.
; The SMT solver should find an overlap.
;
