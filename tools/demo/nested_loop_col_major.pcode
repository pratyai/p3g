sym N, M
var i, j
decl A, B
out A
(A[0], B[0] => A[0]) L_outer | for j = 1 to (M-1):
  (A[0], B[0] => A[0]) L_inner | for i = 0 to (N-1):
    (A[i*M+j], A[i*M+(j-1)], B[j*N+i] => A[i*M+j]) T_comp | op(comp)
; A[i*M+j]= A[i*M+(j-1)] + B[j*N+i]
;
; This example demonstrates a nested loop with explicit column-major access patterns.
; The inner loop's access `A[j*N+(i-1)]` indicates a read from a previous
; iteration in the 'i' dimension.
;
; Expected SMT Result: SAT
; Reason: The access `A[j*N+(i-1)]` implies a read from data potentially written
; by an earlier computation involving `i-1`. This creates a true data dependency
; across iterations in the `i` dimension within the inner loop.
; The SMT solver should find an overlap.
;
