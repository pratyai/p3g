sym N
var k
decl A, B
out A
(A[0], B[0] => A[0]) L1 | for k = 1 to N:
    (A[0], B[0] => A[0]) B1 | if B[k] > 0:
        (A[k-1], A[k] => A[k]) T1_seq | op(comp)
    (B[0] =>) .B2 | if B[k] <= 0:
        (=>) T2_skip | op(comp)

;
; This example demonstrates a "data-aware" branch within a loop.
; The loop's behavior depends on the value of `B[k]`. If `B[k] > 0`, a computation
; `A[k] = A[k-1]` occurs, otherwise, nothing explicit happens (`T2_skip`).
;
; Expected SMT Result: SAT
; Reason: A data dependency exists if the `if B[k] > 0` condition is met across
; consecutive loop iterations, causing `A[k]` to depend on `A[k-1]`.
; The SMT solver should find an assignment to `N` and `B` that satisfies this.
;