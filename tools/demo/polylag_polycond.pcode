sym N
var i
decl A, B
out A
(A[11*11-10:N*N-10], A[0], B[0:N], A[0:N*N] => A[0:N*N]) L1 | for i = 0 to N:
    (A[i*i - 10], B[i], A[i*i] => A[i*i]) B1 | if i*i > 10:
        (A[i*i - 10], B[i], A[i*i] => A[i*i]) C1 | op(A[i*i] = A[i*i - 10] + B[i])
    (A[0], B[i], A[i*i] => A[i*i]) .B2 | if i*i <= 10:
        (A[0], B[i], A[i*i] => A[i*i]) C2 | op(A[i*i] = A[0] + B[i])

;
; This example demonstrates a loop with polymorphic conditions and accesses.
; Array accesses involve polynomial expressions (e.g., `i*i`), and the control
; flow is determined by a conditional branch (`if-else`). This tests the parser's
; ability to handle complex expressions in conditions and access patterns.
;
; Expected SMT Result: UNSAT
; Reason: The query asks whether there exists a fixed data configuration (e.g., `N`,
; initial `A` and `B` values) such that for *every pair* of adjacent iterations (`i`
; and `i+1`), a data dependency *must* exist. The array access patterns (`A[i*i - 10]`,
; `A[0]`, `A[i*i]`) are highly sensitive to the loop variable `i`. It is not possible
; for a single fixed data configuration to cause a dependency (RAW, WAR, or WAW) to hold
; for *all* possible values of `i` within the loop bounds, as the index equality
; conditions would need to hold simultaneously for varying `i`. For example, while
; `A[0]` read at `i=1` depends on `A[0]` written at `i=0`, this specific conflict
; does not generalize to all `i`. Thus, the solver will correctly determine that no
; such data configuration exists that forces a dependency in *every* adjacent iteration pair.
;
