sym N, M
var i, j
decl A, B
out A
(A[?], B[?] => A[?]) L_outer | for i = 1 to N:
  (A[?], A[?], B[?] => A[?]) L_inner | for j = 1 to M:
    (A[j*N+(i-1)], A[j*N+i], B[j*N+i] => A[j*N+i]) T_comp | op(comp)

;
; This example demonstrates a nested loop with column-major access patterns,
; using inferred accesses for the outer loop (`A[?]`). The inner loop's access
; `A[j*N+(i-1)]` indicates a read from a previous iteration in the 'i' dimension.
;
; Expected SMT Result: SAT
; Reason: The access `A[j*N+(i-1)]` implies a read from data potentially written
; by an earlier computation involving `i-1`. This creates a true data dependency
; across iterations in the `i` dimension within the inner loop.
; The SMT solver should find an overlap.
;
