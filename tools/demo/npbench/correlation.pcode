sym M, N
var i, j, k
decl data, mean, stddev, corr, float_n
out corr

; 1. Calculate mean
; mean = np.mean(data, axis=0) -> mean[j] for j in 0..M-1
(mean[0:M-1] => mean[0:M-1]) S_mean_init | op(init_mean)
(data[0,0], mean[0] => mean[0]) L_mean_j | for j = 0 to M-1:
    (data[0:N-1, j], mean[j] => mean[j]) S_mean_accum | op(mean_accum)
    (mean[j] => mean[j]) S_mean_div | op(mean_div)

; 2. Calculate stddev
; stddev = np.sqrt(np.mean(np.subtract(data, mean)**2, axis=0))
(stddev[0:M-1] => stddev[0:M-1]) S_std_init | op(init_std)
(data[0,0], mean[0], stddev[0] => stddev[0]) L_std_j | for j = 0 to M-1:
    (data[0:N-1, j], mean[j], stddev[j] => stddev[j]) S_std_accum | op(std_accum)
    (stddev[j] => stddev[j]) S_std_sqrt | op(std_sqrt)

; 3. Threshold stddev
; stddev[stddev <= 0.1] = 1.0
(stddev[0] => stddev[0]) L_std_thresh | for j = 0 to M-1:
    (stddev[j] => stddev[j]) B_std_check | if (stddev[j]*10) <= 1:
        (stddev[j] => stddev[j]) S_std_set | op(std_set_1)

; 4. Normalize data
; data -= mean
; data /= np.sqrt(float_n) * stddev
(data[0,0], mean[0], stddev[0], float_n[0] => data[0,0]) L_norm_i | for i = 0 to N-1:
    (data[0,0], mean[0], stddev[0], float_n[0] => data[0,0]) L_norm_j | for j = 0 to M-1:
        (data[i,j], mean[j] => data[i,j]) S_sub_mean | op(data_sub_mean)
        (data[i,j], stddev[j], float_n[0] => data[i,j]) S_div_std | op(data_div_std)

; 5. Calculate correlation
; corr = np.eye(M)
(corr[0:M-1, 0:M-1] => corr[0:M-1, 0:M-1]) S_corr_init | op(init_corr_eye)

(data[0,0], corr[0,0] => corr[0,0]) L_corr_i | for i = 0 to M-2:
    ; corr[i, i + 1:M] = data[:, i] @ data[:, i + 1:M]
    ; corr[i + 1:M, i] = corr[i, i + 1:M]
    (data[0,0], corr[0,0] => corr[0,0]) L_corr_j | for j = i+1 to M-1:
        ; Dot product: sum(data[k, i] * data[k, j] for k in 0..N-1)
        (data[0:N-1, i], data[0:N-1, j], corr[i,j] => corr[i,j]) S_corr_calc | op(calc_correlation)
        
        ; Symmetry
        (corr[i,j], corr[j,i] => corr[j,i]) S_corr_sym | op(set_symmetric)
