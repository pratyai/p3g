sym N, TSTEPS
var t, i, j
decl A
out A

(A[0,0] => A[0,0]) L_time | for t = 0 to TSTEPS-2:
    (A[0,0] => A[0,0]) L_i | for i = 1 to N-2:
        ; A[i, 1:-1] += (A[i-1, :-2] + A[i-1, 1:-1] + A[i-1, 2:] + A[i, 2:] + A[i+1, :-2] + A[i+1, 1:-1] + A[i+1, 2:])
        ; Note: The range is 1 to N-2 inclusive (length N-2).
        ; A[i-1, :-2] corresponds to A[i-1, 0:N-3]
        ; A[i-1, 1:-1] corresponds to A[i-1, 1:N-2]
        ; A[i-1, 2:] corresponds to A[i-1, 2:N-1]
        ; etc.
        ; We can merge this into the explicit loop over j below if we want fully explicit scalar ops,
        ; but the python code separates the slice update from the scalar update loop.
        ; However, the slice update `A[i, 1:-1] += ...` updates the whole row segment first.
        ; Then the inner loop `for j` iterates over the same elements and updates them again.
        ; Let's model it as two sequential inner loops or a single merged one if semantics allow.
        ; The Python code:
        ;   A[i, 1:-1] += ... (vectorized add)
        ;   for j in range(1, N-1):
        ;       A[i, j] += A[i, j-1]
        ;       A[i, j] /= 9.0
        ; This means the second update to A[i, j] (the += A[i, j-1]) uses the *new* value of A[i, j-1]
        ; which was just computed in the previous iteration of the `j` loop (Seidel-style dependency).
        ; The first update (vectorized) uses old values (or values from previous `i`).
        ; So we must keep them distinct or ordered correctly.

        ; Step 1: Vectorized update
        (A[0,0] => A[0,0]) L_j_vec | for j = 1 to N-2:
             (A[i,j], A[i-1,j-1], A[i-1,j], A[i-1,j+1], A[i,j+1], A[i+1,j-1], A[i+1,j], A[i+1,j+1] => A[i,j]) S_vec_add | op(stencil_update)

        ; Step 2: Seidel-style update
        (A[0,0] => A[0,0]) L_j_seidel | for j = 1 to N-2:
             (A[i,j], A[i,j-1] => A[i,j]) S_seidel | op(seidel_update_div)
