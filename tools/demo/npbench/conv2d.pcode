decl input, weights, output, accumulator, bias
sym C_in, C_out, H, K, N, W
sym H_out, W_out ; H_out = H - K + 1, W_out = W - K + 1
var i, j, n_batch, k_row, k_col, c_in_loop, c_out, h_out_loop, w_out_loop, c_out_loop

out output

; H_out = H - K + 1
; W_out = W - K + 1
; The values of H_out and W_out are determined by these symbol assignments

; Initialize output array
(output[0, 0, 0, 0] => output[0, 0, 0, 0]) S0_output_init| op(output_init_zeros)

; Outer loop for i
; MAIN OUTER LOOP
(input[0], weights[0], output[0] => output[0]) (S0_output_init).L1_i| for i = 0 to H_out - 1:
    ; Inner loop for j
    (input[0], weights[0], output[0] => output[0]) .L2_j| for j = 0 to W_out - 1:
        ; Loop over batch dimension
        (input[0], weights[0], output[0] => output[0]) .L3_n_batch| for n_batch = 0 to N - 1:
            ; Loop over output channels
            (input[0], weights[0], output[0] => output[0]) .L4_c_out| for c_out = 0 to C_out - 1:
                ; Initialize accumulator for current output element
                (accumulator[0] => accumulator[0]) .S1_accum_init| op(accumulator_init_zero)

                ; Loops for summation (over K, K, C_in)
                (input[0], weights[0], accumulator[0] => accumulator[0]) (S1_accum_init).L5_k_row| for k_row = 0 to K - 1:
                    (input[0], weights[0], accumulator[0] => accumulator[0]) .L6_k_col| for k_col = 0 to K - 1:
                        (input[0], weights[0], accumulator[0] => accumulator[0]) .L7_c_in_loop| for c_in_loop = 0 to C_in - 1:
                            ; Accumulate current element
                            (input[n_batch, i + k_row, j + k_col, c_in_loop], weights[k_row, k_col, c_in_loop, c_out], accumulator[0] => accumulator[0]) .S2_accumulate_element| op(multiply_and_accumulate)
                
                ; Assign accumulated sum to output[n_batch, i, j, c_out]
                (accumulator[0], output[n_batch, i, j, c_out] => output[n_batch, i, j, c_out]) (L7_c_in_loop).S3_output_assign| op(assign_sum_to_output)

; Element-wise addition of bias (for conv2d_bias function)
; This operates on the 'output' generated by the conv2d logic.
(output[0], bias[0] => output[0]) (S3_output_assign).L8_n_bias| for n_batch = 0 to N - 1:
    (output[0], bias[0] => output[0]) .L9_h_bias| for h_out_loop = 0 to H_out - 1:
        (output[0], bias[0] => output[0]) .L10_w_bias| for w_out_loop = 0 to W_out - 1:
            (output[0], bias[0] => output[0]) .L11_c_out_bias| for c_out_loop = 0 to C_out - 1:
                ; output[n_batch, h_out_loop, w_out_loop, c_out_loop] += bias[c_out_loop]
                (output[n_batch, h_out_loop, w_out_loop, c_out_loop], bias[c_out_loop] => output[n_batch, h_out_loop, w_out_loop, c_out_loop]) .S4_add_bias_element| op(add_bias)
