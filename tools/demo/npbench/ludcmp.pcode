sym N
var i, j
decl A, b, x, y
out x, y

; Initializations
(x[0:N-1] => x[0:N-1]) S_init_x | op(init_x_zeros)
(y[0:N-1] => y[0:N-1]) S_init_y | op(init_y_zeros)

; Loop 1: LU decomposition
(A[0,0] => A[0,0]) L_i_decomp | for i = 0 to N-1:
    (A[0,0] => A[0,0]) L_j_lt_i | for j = 0 to i-1:
        ; A[i, j] -= A[i, :j] @ A[:j, j]
        (A[i,j], A[i,0:j-1], A[0:j-1,j] => A[i,j]) S_matmul_sub | op(A_update_sub_matmul)
        ; A[i, j] /= A[j, j]
        (A[i,j], A[j,j] => A[i,j]) S_div | op(A_update_div)
    (A[0,0] => A[0,0]) L_j_ge_i | for j = i to N-1:
        ; A[i, j] -= A[i, :i] @ A[:i, j]
        (A[i,j], A[i,0:i-1], A[0:i-1,j] => A[i,j]) S_matmul_sub2 | op(A_update_sub_matmul_2)

; Loop 2: Forward substitution for y
(A[0,0], b[0], y[0] => y[0]) L_i_fwdsub | for i = 0 to N-1:
    ; y[i] = b[i] - A[i, :i] @ y[:i]
    (b[i], A[i,0:i-1], y[0:i-1], y[i] => y[i]) S_fwdsub | op(y_update_sub_matmul)

; Loop 3: Backward substitution for x
(A[0,0], x[0], y[0] => x[0]) L_i_bwdsub | for i = N-1 to 0:
    ; x[i] = (y[i] - A[i, i + 1:] @ x[i + 1:]) / A[i, i]
    (y[i], A[i,i+1:N-1], x[i+1:N-1], A[i,i], x[i] => x[i]) S_bwdsub | op(x_update_div_sub_matmul)
